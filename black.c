#include "opencv2/imgproc.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <omp.h>
#define N 3 //число заходов в финальном массиве
#define SAVE 1
#ifndef _OPENMP
static_assert(false, "openmp support required");
#endif

#define FTDI 1
#ifdef FTDI
#include <stdlib.h>
extern "C"{
#include <mpsse.h>
}
#define SPEED 10000000
#endif

using namespace cv;
using namespace std;
Mat img;
uint32_t min(uint32_t *, uint32_t);


uint32_t min(uint32_t *data, uint32_t datasize){
	uint32_t min_ind=0;
	for(uint32_t i=0;i<datasize;i++) if(data[i]<data[min_ind]) min_ind=i;
	return min_ind;
};

int main( int argc, const char** argv )
{
    char filename[256]={0};
    strcpy(filename,argv[1]);
    img = imread(filename, IMREAD_GRAYSCALE);
    //Создаём массив с координатами точек контура
    //Изображение предварительно подготовленно
        
    printf("//Mat.rows %u\r\n", img.rows);
    printf("//Mat.cols %u\r\n", img.cols);
    uint8_t *vect_x = (uint8_t*) calloc(img.rows*img.cols+1,sizeof(uint8_t));
    uint8_t *vect_y = (uint8_t*) calloc(img.rows*img.cols+1,sizeof(uint8_t));
    uint32_t n=0;
    
    for( uint64_t i=0;i<img.rows*img.cols;i++){
		if(img.data[i]<100){
			vect_y[n]=i/img.cols;
			vect_x[n]=i%img.cols;
			n++;
			}
		}
	
	printf("//n=%u\r\n",n);
	
	//оптимизируем последовательность точек жадным алгоритмом
	uint32_t * M = (uint32_t*) calloc(n*n+1,sizeof(uint32_t));
	#pragma omp parallel shared(M,vect_x,vect_y) num_threads(8)
	{
	# pragma omp for 
	for(uint32_t i=0;i<n;i++){
		for(uint32_t j=i;j<n;j++){
	//Настоящее расстояние нам не нужно, поэтому корень можно не извлекать
			if(i!=j){
				M[i*n+j]=(uint32_t)(pow((vect_x[i]-vect_x[j]),2)+pow((vect_y[i]-vect_y[j]),2));
				M[j*n+i]=M[i*n+j];
			}
			else M[i*n+j]=0xffffffff;
		}
	}
	}//# pragma omp for
	
	//print_matrix(M,n);
	
	uint32_t *way = (uint32_t*) calloc(img.rows*img.cols+1,sizeof(uint32_t));
	uint32_t *S = (uint32_t*) calloc(n+1,sizeof(uint32_t));
	way[0]=0;
	
	
	for(uint32_t i=1;i<n;i++){
		#pragma omp parallel shared(M) num_threads(8)
			{
			# pragma omp for 
			for(uint32_t j=0;j<n;j++) S[j]=M[way[i-1]*n+j];
			}
		way[i]=min(S,n);
		//printf("min: %u \r\n",way[i]);
		#pragma omp parallel shared(M,way) num_threads(8)
			{
			# pragma omp for 
			for(uint32_t j=0;j<i;j++){
				M[(way[i]*n)+way[j]]=0xffffffff;
				M[(way[j]*n)+way[i]]=0xffffffff;}
			}
		//printf("i=%u way[i]=%u\r\n",i,way[i]);
		//print_matrix(M,n);
		}
	
	//print_mas(way,n);
	
	uint8_t *out = (uint8_t*) calloc(2*n+1,sizeof(uint8_t));
	uint32_t j=0;
	
	for(uint32_t i=0;i<n;i++){
		out[j++]=vect_x[way[i]];
		out[j++]=vect_y[way[i]];
		};
	/**********************************************************
	 * расставляли, расставляли, а теперь замиксуем в N заходов
	 **********************************************************/ 
	uint8_t *out_mix = (uint8_t*) calloc(2*n+1,sizeof(uint8_t));
	j=0;
	uint32_t k=0;
	for(uint32_t i=0;i<N;i++){
		j=2*i;
		do{
			out_mix[k++]=out[j];
			out_mix[k++]=out[j+1];
			j+=2*N;
			}while(j<2*n);
	}
	
	
	//освобождаем память
	free(M);
	free(vect_x);
	free(vect_y);
	free(way);
	free(S);
	free(out);
#ifdef SAVE
	//Сохраняем массив на диск
	char arr_name[256]={0};
	char out_file_name[256]={0};
	
	if(argc>2){
		strcpy(out_file_name,argv[2]);
		strncpy(arr_name, out_file_name,strlen(out_file_name)-2);
		}
	else {
		strncpy(arr_name, filename,strlen(filename)-4);
		strcat(out_file_name,arr_name);
		strcat(out_file_name,".h");
		};
	
	printf("create file %s\r\n",out_file_name);
	FILE *fout;
	fout=fopen(out_file_name,"w");
	
	fprintf(fout,
"//************************************************\r\n\
//final result\r\n\
//generated by c prog black.\r\n\
//Александр Белый 2022\r\n\
//************************************************\r\n");
	fprintf(fout,"static const uint8_t %s[]={\r\n",arr_name);
	fprintf(fout,"%u, ",out_mix[0]);
	for(uint16_t i=1;i<2*n;i++){
		fprintf(fout,"%u, ",out_mix[i]);
		if(!(i%10))fprintf(fout,"\r\n");
		}
	fprintf(fout,"};\r\n");
	fclose(fout);
#endif
#ifdef FTDI
/*****************************************************************
 * А теперь выведем сходу на экран через FT232H
 *****************************************************************/
	struct mpsse_context *spi = NULL;
	spi = MPSSE(SPI0, SPEED, LSB);
	//for(uint8_t i=0;i<20;i++)printf("%u\r\n",out_mix[i]);
	while(1){
	//for(uint64_t i=0; i<600;i++){
		Start(spi);
		FastWrite(spi, (char*)out_mix, 2*n);
		Stop(spi);
		}
	Close(spi);
#endif
	
	

}


